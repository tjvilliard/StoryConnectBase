from typing import Any
from django.db import models
from books.models import Chapter
# from comment.models import TextSelection
from .road_unblocker import RoadUnblocker
import ai_features.utils as utils
from lxml import etree
from .exceptions import StatementSheetInvalidDocumentError
import logging
logger = logging.getLogger(__name__)
# Create your models here.

class RoadUnblockerSuggestion(models.Model):
    '''Model that holds suggestion data generated using LLM.'''

    chapter = models.ForeignKey(Chapter, on_delete=models.CASCADE, related_name='road_unblocker_suggestions')

    suggestion = models.TextField(blank=True, null=True)

    suggestion_type = models.CharField(max_length=50, blank=True, null=True)


class StatementSheet(models.Model):
    """Model that holds the statements generated by the AI."""
    book = models.ForeignKey('books.Book', on_delete=models.CASCADE, related_name='statement_sheets')
    last_run_chapter = models.IntegerField(default=0)
    last_run_offset = models.IntegerField(default=0)
    last_run_response = models.TextField(default="")
    

    document = models.TextField(default="<Statements></Statements>")

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        try:
            self.s_tree = etree.fromstring(self.document)
            self.s_tree = StatementSheet._validate(self.s_tree)
        except etree.XMLSyntaxError as e:
            logger.info(e)
            with(open("ai_features/test_files/invalid_sheet.txt", "w")) as f:
                f.write(self.document)
            raise StatementSheetInvalidDocumentError()
        # self.logger = logging.getLogger(__name__)

    @staticmethod
    def _validate(tree):
        if tree.find("Characters") is None:
            etree.SubElement(tree, "Characters")
        if tree.find("Locations") is None:
            etree.SubElement(tree, "Locations")

        # TODO: make valid with open ai 
        
        return tree

    def get_characters(self):
        # selfs_tree = etree.fromstring(self.document)
        characters = [x.tag for x in self.s_tree.find("Characters")]
        return characters
    
    def get_character_statements(self, character):
        statements = ""

        characters = self.s_tree.find("Characters")
        statements = characters.find(character).text

        return statements

    def get_locations(self):
        places = [x.tag for x in self.s_tree.find("Locations")]
        return places
    
    def get_location_statements(self, location):
        statements = ""

        locations = self.s_tree.find("Locations")
        statements = locations.find(location).text

        return statements
    
    def get_statements(self, tag=None, entity=None):
        if tag is None:
            # return all statements
            statements = ""
            for x in self.s_tree:
                for child in x:
                    statements += child.text
            return statements
        else:
            # return statements for tag
            tag_root = self.s_tree.find(tag)
            if entity:
                return tag_root.find(entity).text
            
            tag_statements = ""
            for x in tag_root:
                tag_statements += x.text
            return tag_statements
    
    def merge_sheets(self, new_sheet):
        n_tree = etree.fromstring(new_sheet)
        n_tree = StatementSheet._validate(n_tree)

        existing_characters = self.get_characters()
        existing_locations = self.get_locations()

        for child in n_tree.find("Characters"):
            if child.tag not in existing_characters:
                self.s_tree.find("Characters").append(child)
            else:
                s_statements = self.get_character_statements(child.tag).split("\n")
                n_statements = child.text.split("\n")
                for n_statement in n_statements:
                    if n_statement not in s_statements:
                        s_statements.append(n_statement)
                
                join_statements = [x.strip() + "\n" for x in s_statements if x != "" and x != "\n" and x != " "]

                self.s_tree.find("Characters").find(child.tag).text = "".join(join_statements)
        
        for child in n_tree.find("Locations"):
            if child.tag not in existing_locations:
                self.s_tree.find("Locations").append(child)
            else:
                s_statements = self.get_location_statements(child.tag).split("\n")
                n_statements = child.text.split("\n")
                for n_statement in n_statements:
                    if n_statement not in s_statements:
                        s_statements.append(n_statement)
                
                join_statements = [x.strip() + "\n" for x in s_statements if x != "" and x != "\n" and x != " "]
                self.s_tree.find("Locations").find(child.tag).text = "".join(join_statements)
        
        self.document = etree.tostring(self.s_tree, pretty_print=True).decode('utf-8')


class ChapterSummary(models.Model):
    """Model that holds the summaries generated by the AI."""
    chapter = models.OneToOneField(Chapter, on_delete=models.CASCADE, related_name='chapter_summary')
    summary = models.TextField(default="")

    def __str__(self) -> str:
        return self.summary
    
    def save(self, *args, **kwargs):
        # self.summary = self.summary.replace("\n", "<br>")
        # TODO: REMEMBER THIS CHANGE 
        #self.summary = utils.summarize_chapter(self.chapter.id)
        self.summary = utils.summarize_chapter_chat(self.chapter.id)

        super().save(*args, **kwargs)

class BookSummary(models.Model):
    """Model that holds the summaries generated by the AI."""
    book = models.OneToOneField('books.Book', on_delete=models.CASCADE, related_name='book_summary')
    summary = models.TextField(default="")
    last_sum_chapter = models.IntegerField(default=-1)

    def __str__(self) -> str:
        return self.summary
    
    # def save(self, *args, **kwargs):
    #     # self.summary = self.summary.replace("\n", "<br>")
    #     self.summary = summarize_book(self.book.id)
    #     super().save(*args, **kwargs)

    # def get_chapter_summaries(self):
    #     summaries = []
    #     for chapter in self.book.get_chapters():
    #         summaries.append(chapter.chapter_summary.summary)
    #     return summaries
    